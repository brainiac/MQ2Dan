/* MQ2DanNet -- peer to peer auto-discovery networking plugin
 *
 * dannuic: version 0.01 -- initial version, can set observers and perform queries, see README.md for more information
 */
// MQ2DanNet.cpp : Defines the entry point for the DLL application.
//

// PLUGIN_API is only to be used for callbacks.  All existing callbacks at this time
// are shown below. Remove the ones your plugin does not use.  Always use Initialize
// and Shutdown for setup and cleanup, do NOT do it in DllMain.

#include <zyre.h> // IMPORTANT! This must be included first because it includes <winsock2.h>, which needs to come before <windows.h> -- we cannot guarantee no inclusion of <windows.h> in other headers
#include "../MQ2Plugin.h"

#include <archive.h>
#include <regex>
#include <iterator>
#include <functional>
#include <numeric>
#include <sstream>
#include <algorithm>
#include <map>
#include <queue>
#include <set>
#include <string>

PLUGIN_VERSION(0.1);
PreSetup("MQ2DanNet");

#pragma region NodeDefs

#ifdef MQ2DANNET_NODE_EXPORTS
#define MQ2DANNET_NODE_API __declspec(dllexport)
#else
#define MQ2DANNET_NODE_API __declspec(dllimport)
#endif

// reduce some boilerplate - we don't actually want to instantiate our commands, so delete all 5 assign/ctors
#define COMMAND(_Name, ...) class _Name {\
public:\
    static const std::string name() { return #_Name; }\
    static const bool callback(std::stringstream&& args);\
    static std::stringstream pack( ##__VA_ARGS__ );\
private:\
    _Name() = delete;\
    _Name(const _Name&) = delete;\
    _Name& operator=(const _Name&) = delete;\
    _Name(_Name&&) = delete;\
    _Name& operator=(_Name&&) = delete;\
}

namespace MQ2DanNet {
    class Node final {
    public:
        MQ2DANNET_NODE_API static Node& get();

        MQ2DANNET_NODE_API void join(const std::string& group);
        MQ2DANNET_NODE_API void leave(const std::string& group);

        MQ2DANNET_NODE_API void on_join(std::function<bool(const std::string&, const std::string&)> callback);
        MQ2DANNET_NODE_API void on_leave(std::function<bool(const std::string&, const std::string&)> callback);

        template<typename T, typename... Args>
        void whisper(const std::string& recipient, Args&&... args) {
            std::stringstream arg_stream = pack<T>(std::forward<Args>(args)...);
            respond(recipient, name<T>(), std::move(arg_stream));
        }

        template<typename T, typename... Args>
        void shout(const std::string& group, Args&&... args) {
            std::stringstream arg_stream = pack<T>(std::forward<Args>(args)...);
            publish(group, name<T>(), std::move(arg_stream));
        }

        MQ2DANNET_NODE_API const std::string get_info();
        MQ2DANNET_NODE_API const std::set<std::string> get_peers();
        MQ2DANNET_NODE_API const std::set<std::string> get_all_groups();
        MQ2DANNET_NODE_API const std::set<std::string> get_own_groups();
        MQ2DANNET_NODE_API const std::map<std::string, std::set<std::string> > get_group_peers();
        MQ2DANNET_NODE_API const std::set<std::string> get_group_peers(const std::string& group);
        MQ2DANNET_NODE_API const std::string get_interfaces();
        MQ2DANNET_NODE_API const std::string get_full_name(const std::string& name);

        // quick helper function to safely init strings from chars
        MQ2DANNET_NODE_API static std::string init_string(const char *szStr);

        template<typename T>
        static const std::string name() { return T::name(); }

        template<typename T>
        static const std::function<bool(std::stringstream&&)> callback() {
            return T::callback;
        }

        // we gotta trust that copy elision works here, which it should in c++14 or more for stringstream.
        // worst case is a slightly slower command because we have to copy the stream
        template<typename T, typename... Args>
        static std::stringstream pack(Args&&... args) { return T::pack(std::forward<Args>(args)...); }

        template<typename T>
        void register_command() { register_command(name<T>(), callback<T>()); }

        template<typename T>
        void unregister_command() { unregister_command(name<T>()); }
        
        // register custom commands (for responses)
        void register_command(const std::string& name, std::function<bool(std::stringstream&&)> callback) { _command_map[name] = callback; }
        void unregister_command(const std::string& name) { _command_map.erase(name); }

        // finds and inserts the next int key, returns `"response" + new_key`
        // this is generated by the requester
        MQ2DANNET_NODE_API std::string register_response(std::function<bool(std::stringstream&&)> callback);
        MQ2DANNET_NODE_API void respond(const std::string& name, const std::string& cmd, std::stringstream&& args);

        struct Observation final {
            MQ2TYPEVAR data;
            unsigned __int64 received;

            Observation(MQ2TYPEVAR data, unsigned __int64 received) : data(data), received(received) {}
            Observation() : received(0) { data.Type = 0; data.Int64 = 0; }
        };

        // finds query and returns the observation group, generates new group name if query not found
        MQ2DANNET_NODE_API std::string register_observer(const std::string& group, const std::string& query);
        MQ2DANNET_NODE_API void observe(const std::string& group, const std::string& name, const std::string& query);
        MQ2DANNET_NODE_API void forget(const std::string& group);
        MQ2DANNET_NODE_API void forget(const std::string& name, const std::string& query);
        MQ2DANNET_NODE_API void update(const std::string& group, const MQ2TYPEVAR& data);
        MQ2DANNET_NODE_API const Observation read(const std::string& group);
        MQ2DANNET_NODE_API const Observation read(const std::string& name, const std::string& query);
        MQ2DANNET_NODE_API void publish(const std::string& group, const std::string& cmd, std::stringstream&& args);

        template<typename T, typename... Args>
        void publish(Args&&... args) {
            for (auto observer_it = _observer_map.begin(); observer_it != _observer_map.end(); ++ observer_it) {
                auto tick = MQGetTickCount64();
                if (tick - observer_it->second.last >= std::max<unsigned __int64>(10 * observer_it->second.benchmark, 1000)) { // wait at least a second between updates
                    std::string group = observer_group(observer_it->first);
                    auto group_peers = get_group_peers();
                    auto group_it = group_peers.cbegin();
                    if (group_it != group_peers.cend() && !group_it->second.empty()) {
                        shout<T>(group_it->first, observer_it->second.query, std::forward<Args>(args)...);

                        auto proc_time = MQGetTickCount64() - tick;
                        if (observer_it->second.benchmark == 0)
                            observer_it->second.benchmark = proc_time;
                        else
                            observer_it->second.benchmark = static_cast<unsigned __int64>(0.5 * (observer_it->second.benchmark + proc_time));

                        observer_it->second.last = tick;
                    }
                }
            }
        }

    private:
        std::string _node_name;

        std::vector<std::function<bool(const std::string&, const std::string&)> > _join_callbacks;
        std::vector<std::function<bool(const std::string&, const std::string&)> > _leave_callbacks;

        // I don't like this, but since zyre/czmq does the memory management for these, I should store these as raw pointers
        zyre_t *_node;
        zactor_t *_actor;

        // command containers
        std::map<std::string, std::function<bool(std::stringstream&& args)> > _command_map; // callback name, callback
        std::queue<std::pair<std::string, std::stringstream> > _command_queue; // pair callback name, callback

        std::set<unsigned char> _response_keys; // ordered number of responses

        struct Query final {
            std::string query;
            unsigned __int64 benchmark;
            unsigned __int64 last;

            //Benchmarks[bmParseMacroParameter];

            Query() = default;
            Query(const std::string& query) : query(query), benchmark(0), last(0) {}

            // let's do some copy and swap for a bit of easy optimization
            friend void swap(Query& left, Query& right) {
                using std::swap;
                swap(left.query, right.query);
                swap(left.benchmark, right.benchmark);
                swap(left.last, right.last);
            }

            Query(const Query& other) : query(other.query), benchmark(other.benchmark), last(other.last) {}
            Query(Query&& other) noexcept : query(std::move(other.query)), benchmark(std::move(other.benchmark)), last(std::move(other.last)) {}
            Query& operator=(Query rhs) { swap(*this, rhs); return *this; }
        };

        struct Observed final {
            std::string query;
            std::string name;

            Observed() = default;
            Observed(const std::string& query, const std::string& name) : query(query), name(name) {}

            friend void swap(Observed& left, Observed& right) {
                using std::swap;
                swap(left.query, right.query);
                swap(left.name, right.name);
            }

            Observed(const Observed& other) : query(other.query), name(other.name) {}
            Observed(Observed&& other) noexcept : query(std::move(other.query)), name(std::move(other.name)) {}
            Observed& operator=(Observed rhs) { swap(*this, rhs); return *this; }
        };

        struct ObservedCompare final {
            bool operator() (const Observed& lhs, const Observed& rhs) const {
                if (lhs.query != rhs.query)
                    return lhs.query < rhs.query;
                else
                    return lhs.name < rhs.name;
            }
        };

        std::map<unsigned int, Query> _observer_map; // group number, query
        std::map<Observed, std::string, ObservedCompare> _observed_map; // maps query to group (for data access)
        std::map<std::string, Observation> _observed_data; // maps group to query result (could be empty)

        static void node_actor(zsock_t *pipe, void *args);
        const std::string observer_group(const unsigned int key);
        void queue_command(const std::string& command, std::stringstream&& args);

        std::string _current_query; // for the Query data member
        Observation _query_result;

        bool _debugging;

        // explicitly prevent copy/move operations.
        Node(const Node&) = delete;
        Node& operator=(const Node&) = delete;
        Node(Node&&) = delete;
        Node& operator=(Node&&) = delete;

        Node();
        ~Node();

    public:
        // IMPORTANT: these are not exposed as an API, this is on purpose! We need a single point of control for our node (this plugin)
        std::string name() { return _node_name; }

        std::string peer_uuid(const std::string& name) {
            std::string uuid("");

            if (_node) {
                zlist_t* peers = zyre_peers(_node);

                if (peers) {
                    const char* z_peer = reinterpret_cast<const char*>(zlist_first(peers));
                    while (z_peer) {
                        std::string peer_name(zyre_peer_header_value(_node, z_peer, "name"));
                        if (name == peer_name) {
                            uuid = z_peer;
                            break;
                        }

                        z_peer = reinterpret_cast<const char*>(zlist_next(peers));
                    }

                    zlist_destroy(&peers);
                }
            }

            return uuid;
        }

        bool has_peer(const std::string& peer) {
            return !peer_uuid(peer).empty();
        }

        size_t peers() {
            if (_node) {
                zlist_t* peers = zyre_peers(_node);
                if (peers) {
                    size_t count = zlist_size(peers);
                    zlist_destroy(&peers);
                    return count;
                }
            }

            return 0;
        }

        std::string peers_arr();

        // smartly reads/sets/clears _current_query
        Observation query(const std::string& query);
        void query_result(const Observation& obs);

        bool debugging(bool debugging) { _debugging = debugging; return _debugging; }
        bool debugging() { return _debugging; }

        void enter();
        void exit();
        void shutdown();

        void do_next();
    };
}

#pragma endregion

#pragma region CommandDefs

namespace MQ2DanNet {
    COMMAND(Echo, const std::string& message);

    COMMAND(Execute, const std::string& command);

    // NOTE: Query is asynchronous
    COMMAND(Query, const std::string& request);

    COMMAND(Observe, const std::string& query);

    COMMAND(Update, const std::string& query);
}

#pragma endregion

using namespace MQ2DanNet;

#pragma region Node

MQ2DANNET_NODE_API Node& Node::get() {
    static Node instance;
    return instance;
}

MQ2DANNET_NODE_API void Node::join(const std::string& group) {
    if (_node) zyre_join(_node, group.c_str());
}

MQ2DANNET_NODE_API void Node::leave(const std::string& group) {
    if (_node) zyre_leave(_node, group.c_str());
}

MQ2DANNET_NODE_API void MQ2DanNet::Node::on_join(std::function<bool(const std::string&, const std::string&)> callback) {
    _join_callbacks.push_back(std::move(callback));
}

MQ2DANNET_NODE_API void MQ2DanNet::Node::on_leave(std::function<bool(const std::string&, const std::string&)> callback) {
    _leave_callbacks.push_back(std::move(callback));
}

MQ2DANNET_NODE_API void Node::publish(const std::string& group, const std::string& cmd, std::stringstream&& args) {
    if (!_node)
        return;

    args.seekg(0, args.end);
    size_t args_size = (size_t)args.tellg();
    args.seekg(0, args.beg);

    char *args_buf = new char[args_size];
    args.read(args_buf, args_size);

    zframe_t *args_frame = zframe_new(args_buf, args_size);

    zmsg_t *msg = zmsg_new();
    zmsg_prepend(msg, &args_frame);
    zmsg_pushstr(msg, cmd.c_str());

    zyre_shout(_node, group.c_str(), &msg);

    delete[] args_buf;
}

MQ2DANNET_NODE_API void Node::respond(const std::string& name, const std::string& cmd, std::stringstream&& args) {
    if (!_node)
        return;

    std::string uuid = peer_uuid(name);
    if (!uuid.empty()) {
        std::transform(uuid.begin(), uuid.end(), uuid.begin(), ::toupper);

        args.seekg(0, args.end);
        size_t args_size = (size_t)args.tellg();
        args.seekg(0, args.beg);

        char *args_buf = new char[args_size];
        args.read(args_buf, args_size);

        zframe_t *args_frame = zframe_new(args_buf, args_size);

        zmsg_t *msg = zmsg_new();
        zmsg_prepend(msg, &args_frame);
        zmsg_pushstr(msg, cmd.c_str());

        zyre_whisper(_node, uuid.c_str(), &msg);

        delete[] args_buf;
    }
}

MQ2DANNET_NODE_API const std::string Node::get_info() {
    if (!_node)
        return "NONET";

    std::stringstream output;
    output << _node_name << " " << zyre_uuid(_node);

    output << std::endl << "PEERS: ";
    auto peers = get_peers();
    for (auto peer : peers) {
        output << std::endl << " --> " << zyre_peer_header_value(_node, peer.c_str(), "name"); // don't worry about the UUID, let's just keep that hidden.
    }

    output << std::endl << "GROUPS: ";
    std::set<std::string> groups = get_all_groups();
    for (auto group : groups) {
        output << std::endl << " --> " << group;
    }

    groups = get_own_groups();
    output << std::endl << "GROUP PEERS: ";
    auto group_peers = get_group_peers();
    for (auto group : group_peers) {
        output << std::endl << " :: " << group.first;
        if (groups.find(group.first) != groups.end()) {
            output << std::endl << " --> " << _node_name;
        }

        for (auto peer : group.second) {
            output << std::endl << " --> " << zyre_peer_header_value(_node, peer.c_str(), "name");
        }
    }

    return output.str();
}

MQ2DANNET_NODE_API const std::set<std::string> MQ2DanNet::Node::get_peers() {
    std::set<std::string> peers;

    if (_node) {
        zlist_t* peer_ids = zyre_peers(_node);
        if (peer_ids) {
            const char *peer_id = reinterpret_cast<const char*>(zlist_first(peer_ids));
            while (peer_id) {
                peers.emplace(peer_id);
                peer_id = reinterpret_cast<const char*>(zlist_next(peer_ids));
            }

            zlist_destroy(&peer_ids);
        }
    }

    return peers;
}

MQ2DANNET_NODE_API const std::set<std::string> MQ2DanNet::Node::get_all_groups() {
    std::set<std::string> groups;

    if (_node) {
        zlist_t* peer_groups = zyre_peer_groups(_node);
        if (peer_groups) {
            const char *peer_group = reinterpret_cast<const char *>(zlist_first(peer_groups));
            while (peer_group) {
                groups.emplace(peer_group);
                peer_group = reinterpret_cast<const char*>(zlist_next(peer_groups));
            }

            zlist_destroy(&peer_groups);
        }

        std::set<std::string> own_groups = get_own_groups();
        groups.insert(own_groups.begin(), own_groups.end());
    }

    return groups;
}

MQ2DANNET_NODE_API const std::set<std::string> MQ2DanNet::Node::get_own_groups() {
    std::set<std::string> groups;

    if (_node) {
        zlist_t* peer_groups = zyre_own_groups(_node);
        if (peer_groups) {
            const char *peer_group = reinterpret_cast<const char *>(zlist_first(peer_groups));
            while (peer_group) {
                groups.emplace(peer_group);
                peer_group = reinterpret_cast<const char*>(zlist_next(peer_groups));
            }

            zlist_destroy(&peer_groups);
        }
    }

    return groups;
}

MQ2DANNET_NODE_API const std::map<std::string, std::set<std::string>> MQ2DanNet::Node::get_group_peers() {
    std::map<std::string, std::set<std::string> > group_peers;

    if (_node) {
        std::set<std::string> groups = get_all_groups();
        for (auto group : groups) {
            group_peers[group] = get_group_peers(group);
        }
    }

    return group_peers;
}

MQ2DANNET_NODE_API const std::set<std::string> MQ2DanNet::Node::get_group_peers(const std::string & group) {
    std::set<std::string> peers;

    if (_node) {
        zlist_t* z_peers = zyre_peers_by_group(_node, group.c_str());
        if (z_peers) {
            const char *z_peer = reinterpret_cast<const char*>(zlist_first(z_peers));
            while (z_peer) {
                peers.emplace(z_peer);
                z_peer = reinterpret_cast<const char*>(zlist_next(z_peers));
            }

            zlist_destroy(&z_peers);
        }
    }

    return peers;
}

MQ2DANNET_NODE_API const std::string MQ2DanNet::Node::get_interfaces() {
    ziflist_t *l = ziflist_new();
    std::string ifaces = ziflist_first(l);
    while (auto iface = ziflist_next(l)) {
        ifaces += "\r\n";
        ifaces += iface;
    }
    
    ziflist_destroy(&l);

    return ifaces;
}

MQ2DANNET_NODE_API const std::string MQ2DanNet::Node::get_full_name(const std::string& name) {
    std::string ret = name;

    // this works because names and servers can't have underscores in them, therefore if 
    // there is no underscore in the string, we assume a local character name was passed
    if (std::string::npos == name.find_last_of("_")) {
        ret = EQADDR_SERVERNAME + std::string("_") + ret;
    }

    std::transform(ret.begin(), ret.end(), ret.begin(), ::tolower);
    return init_string(ret.c_str());
}

void Node::node_actor(zsock_t *pipe, void *args) {
    Node *node = reinterpret_cast<Node*>(args);
    if (!node) return;


    node->_node = zyre_new(node->_node_name.c_str());
    if (!node->_node) throw new std::invalid_argument("Could not create node");

    CHAR szInterface[MAX_STRING] = { 0 };
    GetPrivateProfileString("MQ2DanNet", "Interface", "", szInterface, MAX_STRING, INIFileName);
    if (szInterface && strlen(szInterface) > 0) {
        zyre_set_interface(node->_node, szInterface);
    }

    // send our node name for easier name recognition
    zyre_set_header(node->_node, "name", "%s", node->_node_name.c_str());
    zyre_start(node->_node);

    zsock_signal(pipe, 0); // ready signal, required by zactor contract
    
    auto my_sock = zyre_socket(node->_node);
    zpoller_t *poller = zpoller_new(pipe, my_sock, (void*)NULL);

    // TODO: This doesn't appear necessary, but experiment with it
    //zpoller_set_nonstop(poller, true);

    DebugSpewAlways("Starting actor loop for %s : %s", node->_node_name.c_str(), zyre_uuid(node->_node));

    bool terminated = false;
    while (!terminated) {
        void *which = zpoller_wait(poller, -1);

        bool did_expire = zpoller_expired(poller);
        bool did_terminate = zpoller_terminated(poller);
        if (which == pipe) {
            // we've got a command from the caller here
            //DebugSpewAlways("Got message from caller");
            zmsg_t *msg = zmsg_recv(which);
            if (!msg) break; // Interrupted

            // strings index commands because zeromq has the infrastructure and it's not time-critical
            // otherwise, we'd have to deal with byte streams, which is totally unnecessary
            char *command = zmsg_popstr(msg);
            zframe_t *body = zmsg_pop(msg);
            char *name = zmsg_popstr(msg);
            char *group = zmsg_popstr(msg);

            DebugSpewAlways("command: %s, name: %s, group: %s", command, name, group);

            if (streq(command, "$TERM")) // need to handle $TERM per zactor contract
                terminated = true;
            else {
                std::stringstream args;
                Archive<std::stringstream> args_ar(args);
                args_ar << std::string(name ? name : "") << std::string(group ? group : "");
                char *body_data = (char *)zframe_data(body);
                size_t body_size = zframe_size(body);

                args.write(body_data, body_size);

                node->queue_command(command, std::move(args));
            }

            if (group) free(group);
            if (name) free(name);
            if (body) zframe_destroy(&body);
            if (command) free(command);

            zmsg_destroy(&msg);
        } else if (which == zyre_socket(node->_node)) {
            // we've received something over our socket
            //DebugSpewAlways("Got a message over the socket");
            zyre_event_t *z_event = zyre_event_new(node->_node);
            if (!z_event) break;

            const char *szEventType = zyre_event_type(z_event);
            std::string event_type(szEventType ? szEventType : ""); // don't use init_string() because we don't want to make lower
            std::string name = init_string(zyre_event_peer_name(z_event));

            if (event_type.empty()) {
                DebugSpewAlways("MQ2DanNet: Got zyre message with empty event type!");
            } else if (name.empty()) {
                DebugSpewAlways("MQ2DanNet: Got %s message with empty name!", event_type.c_str());
            } else if (event_type == "ENTER") {
                // TODO: can possibly do something with headers here (`zyre_event_headers(z_event)`)
                // can also harvest the IP:port if we need it
                std::string uuid = init_string(zyre_event_peer_uuid(z_event));
                if (uuid.empty()) {
                    DebugSpewAlways("MQ2DanNet: ENTER with empty UUID for name %s, will not add to peers list.", name.c_str());
                }
                //DebugSpewAlways("%s is ENTERing.", name.c_str());
            } else if (event_type == "EXIT") {
                // nothing to do here
                //DebugSpewAlways("%s is EXITing.", name.c_str());
            } else if (event_type == "JOIN") {
                std::string group = init_string(zyre_event_group(z_event));

                if (group.empty()) {
                    DebugSpewAlways("MQ2DanNet: JOIN with empty group with name %s, will not add to lists.", name.c_str());
                } else {
                    for (auto callback_it = node->_join_callbacks.begin(); callback_it != node->_join_callbacks.end(); ) {
                        if ((*callback_it)(name, group))
                            node->_join_callbacks.erase(callback_it);
                        else
                            ++callback_it;
                    }
                    DebugSpewAlways("JOIN %s : %s", group.c_str(), name.c_str());
                }
            } else if (event_type == "LEAVE") {
                std::string group = init_string(zyre_event_group(z_event));

                if (group.empty()) {
                    DebugSpewAlways("MQ2DanNet: LEAVE with empty group with name %s, will not remove from lists.", name.c_str());
                } else {
                    for (auto callback_it = node->_leave_callbacks.begin(); callback_it != node->_leave_callbacks.end(); ) {
                        if ((*callback_it)(name, group))
                            node->_leave_callbacks.erase(callback_it);
                        else
                            ++callback_it;
                    }
                }
                DebugSpewAlways("LEAVE %s : %s", group.c_str(), name.c_str());
            } else if (event_type == "WHISPER") {
                // use get_msg because we want ownership to pass the command up
                zmsg_t *message = zyre_event_get_msg(z_event);
                if (!message) {
                    DebugSpewAlways("MQ2DanNet: Got NULL WHISPER message from %s", name.c_str());
                } else {
                    zmsg_addstr(message, name.c_str());
                    zmsg_send(&message, node->_actor);
                }
            } else if (event_type == "SHOUT") {
                // this presumes that group will return NULL if not a shot, which is valid in zyre if we don't set ZYRE_DEBUG or ZYRE_PEDANTIC
                std::string group = init_string(zyre_event_group(z_event));

                if (group.empty()) {
                    DebugSpewAlways("MQ2DanNet: SHOUT with empty group from %s, not passing message.", name.c_str());
                } else {
                    // use get_msg because we want ownership to pass the command up
                    zmsg_t *message = zyre_event_get_msg(z_event);
                    if (!message) {
                        DebugSpewAlways("MQ2DanNet: Got NULL SHOUT message from %s in %s", name.c_str(), group.c_str());
                    } else {
                        // note that this goes to the end of the message
                        zmsg_addstr(message, name.c_str());
                        zmsg_addstr(message, group.c_str()); 
                        zmsg_send(&message, node->_actor);
                    }
                }
            } else if (event_type == "EVASIVE") {
                // not sure if anything needs to be done here?
                // also, turns out this is done a lot so let's just mute it to reduce spam
                //TODO: need to maintain a keepalive list so we can remove peers that have disconnected (how to force remove peers? it might be a command to the actor, look this up.)
                //auto tick = MQGetTickCount64();
                //DebugSpewAlways("%s is being evasive at %ull.", name.c_str(), tick);
            } else {
                DebugSpewAlways("MQ2DanNet: Got unhandled event type %s.", event_type.c_str());
            }

            zyre_event_destroy(&z_event);
        }
    }

    zpoller_destroy(&poller);

    auto groups = node->get_own_groups();
    for (auto group : groups)
        node->leave(group);

    zyre_stop(node->_node);
    zclock_sleep(100);
    zyre_destroy(&node->_node);
}

std::string Node::init_string(const char *szStr) {
    if (szStr) {
        std::string str(szStr);
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);
        return str;
    }

    return std::string();
}

MQ2DANNET_NODE_API std::string MQ2DanNet::Node::register_response(std::function<bool(std::stringstream&&)> callback) {
    // C99, 6.2.5p9 -- guarantees that this will wrap to 0 once we reach max value
    unsigned char next_val = *(_response_keys.crbegin()) + 1;
    _response_keys.insert(next_val);
    std::string key = "response_" + std::to_string((unsigned int)next_val);

    register_command(key, callback);
    return key;
}

// this is pretty much fire and forget. We could potentially have a bunch of vacant observers, but don't worry about that, let's just test it.
// if we have to start dropping observer groups, then we need to figure out a way to gracefully handle desyncs
// potentially on_join if no group is available, have the client re-register?
MQ2DANNET_NODE_API std::string MQ2DanNet::Node::register_observer(const std::string& name, const std::string& query) {
    // first search for the key in the map already
    for (auto observer : _observer_map) {
        if (observer.second.query == query)
            return observer_group(observer.first);
    }

    // didn't find anything, insert a new one
    Query obs(query);

    // C99, 6.2.5p9 -- guarantees that this will wrap to 0 once we reach max value
    unsigned int position = _observer_map.crbegin()->first + 1;

    _observer_map[position] = std::move(obs);
    return observer_group(position);
}

MQ2DANNET_NODE_API void MQ2DanNet::Node::observe(const std::string& group, const std::string& name, const std::string& query) {
    join(group);
    _observed_map[Observed(query, name)] = group;
}

MQ2DANNET_NODE_API void MQ2DanNet::Node::forget(const std::string& group) {
    auto map_it = std::find_if(_observed_map.begin(), _observed_map.end(), [group](const std::pair<Observed, std::string> kv) { return kv.second == group; });
    if (map_it != _observed_map.end())
        _observed_map.erase(map_it);

    _observed_data.erase(group);

    leave(group);
}

MQ2DANNET_NODE_API void MQ2DanNet::Node::forget(const std::string& name, const std::string& query) {
    auto map_it = _observed_map.find(Observed(query, name));
    if (map_it != _observed_map.end()) {
        std::string group = map_it->second;
        _observed_data.erase(group);
        _observed_map.erase(map_it);

        leave(group);
    }
}

MQ2DANNET_NODE_API void MQ2DanNet::Node::update(const std::string& group, const MQ2TYPEVAR& data) {
    auto data_it = _observed_data.find(group);
    if (data_it != _observed_data.end()) {
        data_it->second.data = data;
        data_it->second.received = MQGetTickCount64();
    } else {
        Observation obs;
        obs.data = data;
        obs.received = MQGetTickCount64();
        _observed_data[group] = obs;
    }
}

MQ2DANNET_NODE_API const Node::Observation MQ2DanNet::Node::read(const std::string& group) {
    auto data_it = _observed_data.find(group);
    if (data_it != _observed_data.end()) {
        return data_it->second;
    } else {
        return Observation();
    }
}

MQ2DANNET_NODE_API const Node::Observation MQ2DanNet::Node::read(const std::string& name, const std::string& query) {
    auto map_it = _observed_map.find(Observed(query, name));
    if (map_it != _observed_map.end()) {
        return read(map_it->second);
    } else {
        return Observation();
    }
}

// stub these for now, nothing to do here since memory is managed elsewhere (and all registered commands will go away)
Node::Node() {}
Node::~Node() {}

std::string MQ2DanNet::Node::peers_arr() {
    if (_node) {
        std::set<std::string> peers_ref = get_peers();
        std::set<std::string>peers;
        std::transform(peers_ref.begin(), peers_ref.end(), std::inserter(peers, peers.begin()), [node(_node)](std::string peer) -> std::string {
            return zyre_peer_header_value(node, peer.c_str(), "name");
        });

        std::string delimiter = "|";
        return std::accumulate(peers.cbegin(), peers.cend(), std::string(),
            [delimiter](const std::string& s, const std::string& p) {
            return s + (s.empty() ? std::string() : delimiter) + p;
        });
    }

    return std::string();
}

Node::Observation MQ2DanNet::Node::query(const std::string& query) {
    if (query.empty() || query != _current_query) {
        _current_query = query;
        _query_result = Observation();
    }

    return _query_result;
}

void MQ2DanNet::Node::query_result(const Observation& obs) {
    _query_result = obs;
}

void Node::enter() {
    PCHARINFO pChar = GetCharInfo();
    if (!pChar)
        return;

    _node_name = get_full_name(pChar->Name);

    DebugSpewAlways("Spinning up actor for %s", _node_name.c_str());
    _actor = zactor_new(Node::node_actor, this);
}

void Node::exit() {
    if (_actor) {
        DebugSpewAlways("Destroying actor for %s", _node_name.c_str());
        zactor_destroy(&_actor);
    } else if (_node) {
        // in general destroying the zactor will do this, but just in case it's dangling, let's be safe
        DebugSpewAlways("WARNING: had a node without an actor in %s", _node_name.c_str());
        zyre_destroy(&_node);
    }

    _node_name = "";
}

void MQ2DanNet::Node::shutdown() {
    zsys_shutdown();
}

void Node::queue_command(const std::string& command, std::stringstream&& args) {
    // defer the actual lookup to the execution so we can handle commands that remove themselves
    _command_queue.emplace(std::make_pair(command, std::move(args)));
}

const std::string MQ2DanNet::Node::observer_group(const unsigned int key) {
    return _node_name + "_" + init_string(std::to_string(key).c_str());
}

void Node::do_next() {
    if (!_command_queue.empty()) {
        std::pair<const std::string, std::stringstream> command_pair = std::move(_command_queue.front());
        _command_queue.pop(); // go ahead and pop it off, we've moved it

        auto command_it = _command_map.find(command_pair.first);
        if (command_it != _command_map.end() && 
            command_it->second(std::move(command_pair.second))) // return true to remove the command from the map
            _command_map.erase(command_it); // this is safe because we aren't looping here
    }
}

#pragma endregion

#pragma region Commands

const bool MQ2DanNet::Echo::callback(std::stringstream&& args) {
    Archive<std::stringstream> received(args);
    std::string from;
    std::string group;
    std::string text;

    try {
        received >> from >> group >> text;
        DebugSpewAlways("ECHO --> FROM: %s, GROUP: %s, TEXT: %s", from.c_str(), group.c_str(), text.c_str());

        if (group.empty())
            WriteChatf("\ax\a-t[\ax\at %s \ax\a-t]\ax \aw%s\ax", from.c_str(), text.c_str());
        else
            WriteChatf("\ax\a-t[\ax\at %s\ax\a-t (%s) ]\ax \aw%s\ax", from.c_str(), group.c_str(), text.c_str());

        return false;
    } catch (std::runtime_error&) {
        DebugSpewAlways("MQ2DanNet::Echo -- Failed to deserialize.");
        return false;
    }
}

std::stringstream MQ2DanNet::Echo::pack(const std::string& message) {
    std::stringstream send_stream;
    Archive<std::stringstream> send(send_stream);
    send << message;
    
    return send_stream;
}

const bool MQ2DanNet::Execute::callback(std::stringstream&& args) {
    Archive<std::stringstream> received(args);
    std::string from;
    std::string group;
    std::string command;

    try {
        received >> from >> group >> command;
        DebugSpewAlways("EXECUTE --> FROM: %s, GROUP: %s, TEXT: %s", from.c_str(), group.c_str(), command.c_str());

        std::string final_command = std::regex_replace(command, std::regex("\\$\\\\\\{"), "${");

        if (group.empty()) {
            WriteChatf("\ax\a-o[\ax\ao %s \ax\a-o]\ax \aw%s\ax", from.c_str(), final_command.c_str());
        } else {
            WriteChatf("\ax\a-o[\ax\ao %s\ax\a-o (%s) ]\ax \aw%s\ax", from.c_str(), group.c_str(), final_command.c_str());
        }

        CHAR szCommand[MAX_STRING] = { 0 };
        strcpy_s(szCommand, final_command.c_str());
        EzCommand(szCommand);

        return false;
    } catch (std::runtime_error&) {
        DebugSpewAlways("MQ2DanNet::Echo -- Failed to deserialize.");
        return false;
    }
}

std::stringstream MQ2DanNet::Execute::pack(const std::string& command) {
    std::stringstream send_stream;
    Archive<std::stringstream> send(send_stream);
    send << command;

    return send_stream;
}

const bool MQ2DanNet::Query::callback(std::stringstream&& args) {
    Archive<std::stringstream> received(args);
    std::string from;
    std::string group; // this is irrelevant, but we need to pull the parameter anyway.
    std::string key;
    std::string request;

    try {
        received >> from >> group >> key >> request;
        DebugSpewAlways("QUERY --> FROM: %s, GROUP: %s, REQUEST: %s", from.c_str(), group.c_str(), request.c_str());

        std::stringstream send_stream;
        Archive<std::stringstream> send(send_stream);

        PCHARINFO pChar = GetCharInfo();
        if (pChar) {
            std::string final_request = std::regex_replace(request, std::regex("\\$\\\\\\{"), "${");

            CHAR szQuery[MAX_STRING];
            strcpy_s(szQuery, final_request.c_str());
            MQ2TYPEVAR Result;

            // Since we don't surround the query with ${}, we want to parse all the variables specified inside
            ParseMacroData(szQuery, MAX_STRING);
            // Then after all of that, we need to Evaluate the entire thing as a single variable
            // Can retrieve this data with `FindMQ2DataType(Result.Type->GetName());` and then `Result.Type->FromString(Result.VarPtr, szBuf);`
            if (ParseMQ2DataPortion(szQuery, Result) && Result.Type) {
                CHAR szBuf[MAX_STRING] = { 0 };
                strcpy_s(szBuf, Result.Type->GetName());
                if (!szBuf) strcpy_s(szBuf, "NULL");
                send << szBuf;

                Result.Type->ToString(Result.VarPtr, szBuf);
                if (!szBuf) strcpy_s(szBuf, "NULL");
                send << szBuf;
            } else {
                send << "NULL" << "NULL";
            }

            Node::get().respond(from, key, std::move(send_stream));
        } else {
            DebugSpewAlways("MQ2DanNet::Query::callback -- failed to GetCharInfo(), sending empty response.");
            Node::get().respond(from, key, std::move(std::stringstream()));
        }

        return false;
    } catch (std::runtime_error&) {
        DebugSpewAlways("MQ2DanNet::Query -- Failed to deserialize.");
        return false;
    }
}

// we're going to generate a new command and register it with Node here in addition to packing
std::stringstream MQ2DanNet::Query::pack(const std::string& request) {
    std::stringstream send_stream;
    Archive<std::stringstream> send(send_stream);

    Node::get().query(""); // first clear -- we want a Query message to get a fresh response
    Node::get().query(request); // now set our most recent request (the return won't matter here)
    auto f = [](std::stringstream&& args) -> bool {
        Archive<std::stringstream> ar(args);
        std::string from;
        std::string group;
        std::string type;
        std::string data;

        try {
            ar >> from >> group >> type >> data;

            MQ2TYPEVAR Result;

            CHAR szBuf[MAX_STRING] = { 0 };
            strcpy_s(szBuf, type.c_str());
            Result.Type = FindMQ2DataType(szBuf);

            strcpy_s(szBuf, data.c_str());
            if (Result.Type && Result.Type->FromString(Result.VarPtr, szBuf)) {
                Node::get().query_result(Node::Observation(Result, MQGetTickCount64()));
                if (Node::get().debugging())
                    WriteChatf("%s : %s -- %llu (%llu)", type.c_str(), data.c_str(), Node::get().read(group).received, MQGetTickCount64());
            } else {
                if (Node::get().debugging())
                    WriteChatf("%s : %s -- Failed to read data %llu.", type.c_str(), data.c_str(), MQGetTickCount64());
            }
        } catch (std::runtime_error&) {
            DebugSpewAlways("MQ2DanNet::Query -- response -- Failed to deserialize.");
        }

        return true;
    };

    std::string key = Node::get().register_response(f);
    send << key << request;

    return send_stream;
}

// this is the callback for the observable, so add to map and send back the result group to the requester
const bool MQ2DanNet::Observe::callback(std::stringstream&& args) {
    Archive<std::stringstream> received(args);
    std::string from;
    std::string group;
    std::string key;
    std::string query;

    try {
        received >> from >> group >> key >> query;
        DebugSpewAlways("OBSERVE --> FROM: %s, GROUP: %s, QUERY: %s", from.c_str(), group.c_str(), query.c_str());

        std::string final_query = std::regex_replace(query, std::regex("\\$\\\\\\{"), "${");

        CHAR szQuery[MAX_STRING];
        strcpy_s(szQuery, final_query.c_str());
        MQ2TYPEVAR Result;

        std::stringstream args;
        Archive<std::stringstream> ar(args);

        // only install the observer if it is a valid query
        ParseMacroData(szQuery, MAX_STRING);
        if (ParseMQ2DataPortion(szQuery, Result) && Result.Type) {
            std::string return_group = Node::get().register_observer(from.c_str(), query.c_str());
            ar << return_group;
        } else {
            ar << "NULL";
        }

        Node::get().respond(from, key, std::move(args));
    } catch (std::runtime_error&) {
        DebugSpewAlways("MQ2DanNet::Observe -- Failed to deserialize.");
    }

    return false;
}

std::stringstream MQ2DanNet::Observe::pack(const std::string& query) {
    std::stringstream send_stream;
    Archive<std::stringstream> send(send_stream);

    // this is the callback to actually start observing. We can't just do it because the observed will come back with the right group 
    auto f = [query](std::stringstream&& args) -> bool {
        Archive<std::stringstream> ar(args);
        std::string from;
        std::string group;
        std::string new_group;

        try {
            ar >> from >> group >> new_group;
            if (new_group != "NULL") {
                Node::get().observe(new_group, from, query);
            }
        } catch (std::runtime_error&) {
            DebugSpewAlways("MQ2DanNet::Observe -- response -- Failed to deserialize.");
        }

        return true;
    };

    // this registers the response from the observed that responds with a group name
    std::string key = Node::get().register_response(f);
    send << key << query;
    return send_stream;
}

const bool MQ2DanNet::Update::callback(std::stringstream&& args) {
    Archive<std::stringstream> received(args);
    std::string from;
    std::string group;
    std::string type;
    std::string data;

    try {
        received >> from >> group >> type >> data;
        DebugSpewAlways("UPDATE --> FROM: %s, GROUP: %s, DATA: %s", from.c_str(), group.c_str(), data.c_str());

        MQ2TYPEVAR Result;

        CHAR szBuf[MAX_STRING] = { 0 };
        strcpy_s(szBuf, type.c_str());
        Result.Type = FindMQ2DataType(szBuf);
        
        strcpy_s(szBuf, data.c_str());
        if (Result.Type && Result.Type->FromString(Result.VarPtr, szBuf)) {
            Node::get().update(group, Result);
            if (Node::get().debugging())
                WriteChatf("%s : %s -- %llu (%llu)", type.c_str(), data.c_str(), Node::get().read(group).received, MQGetTickCount64());
        } else {
            if (Node::get().debugging())
                WriteChatf("%s : %s -- Failed to read data %llu.", type.c_str(), data.c_str(), MQGetTickCount64());
        }
    } catch (std::runtime_error&) {
        DebugSpewAlways("MQ2DanNet::Update -- failed to deserialize.");
    }

    return false;
}

std::stringstream MQ2DanNet::Update::pack(const std::string& query) {
    std::stringstream send_stream;
    Archive<std::stringstream> send(send_stream);

    PCHARINFO pChar = GetCharInfo();
    if (pChar) {
        std::string final_query = std::regex_replace(query, std::regex("\\$\\\\\\{"), "${");

        CHAR szQuery[MAX_STRING];
        strcpy_s(szQuery, final_query.c_str());
        MQ2TYPEVAR Result;

        // Since we don't surround the query with ${}, we want to parse all the variables specified inside
        ParseMacroData(szQuery, MAX_STRING);
        // Then after all of that, we need to Evaluate the entire thing as a single variable
        // Can retrieve this data with `FindMQ2DataType(Result.Type->GetName());` and then `Result.Type->FromString(Result.VarPtr, szBuf);`
        if (ParseMQ2DataPortion(szQuery, Result) && Result.Type) {
            CHAR szBuf[MAX_STRING] = { 0 };
            strcpy_s(szBuf, Result.Type->GetName());
            if (!szBuf) strcpy_s(szBuf, "NULL");
            send << szBuf;

            Result.Type->ToString(Result.VarPtr, szBuf);
            if (!szBuf) strcpy_s(szBuf, "NULL");
            send << szBuf;
        } else {
            send << "NULL" << "NULL";
        }

    } else {
        DebugSpewAlways("MQ2DanNet::Update::pack -- failed to GetCharInfo(), sending empty response.");
    }

    return send_stream;
}

#pragma endregion

#pragma region MainPlugin

class MQ2DanNetType *pDanNetType = nullptr;
class MQ2DanNetType : public MQ2Type {
private:
    std::string Peer;
    CHAR Buf[MAX_STRING];

public:
    enum Members {
        Name,
        PeerCount,
        Peers,
        O,
        Observe,
        Q,
        Query
    };

    MQ2DanNetType() : MQ2Type("DanNet") {
        TypeMember(Name);
        TypeMember(PeerCount);
        TypeMember(Peers);
        TypeMember(O);
        TypeMember(Observe);
        TypeMember(Q);
        TypeMember(Query);
    }

    bool GetMember(MQ2VARPTR VarPtr, char* Member, char* Index, MQ2TYPEVAR &Dest) {
        Buf[0] = '\0';

        std::string local_peer = Peer;
        Peer.clear();

        PMQ2TYPEMEMBER pMember = MQ2DanNetType::FindMember(Member);
        if (!pMember) return false;

        switch ((Members)pMember->ID) {
        case Name:
            strcpy_s(Buf, Node::get().name().c_str());
            Dest.Ptr = Buf;
            Dest.Type = pStringType;
            return true;
        case PeerCount:
            Dest.DWord = Node::get().peers();
            Dest.Type = pIntType;
            return true;
        case Peers:
            strcpy_s(Buf, Node::get().peers_arr().c_str());
            Dest.Ptr = Buf;
            Dest.Type = pStringType;
            return true;
        }

        if (!local_peer.empty()) {
            switch ((Members)pMember->ID) {
            case O:
            case Observe:
                if (Index && Index[0] != '\0') {
                    Dest = Node::get().read(local_peer, Index).data;
                    if (Dest.Type == 0) {
                        // we didn't have this observer in our map
                        // first, let's set the return
                        strcpy_s(Buf, "NULL");
                        Dest.Ptr = Buf;
                        Dest.Type = pStringType;

                        // next, let's submit a request for the observer
                        Node::get().whisper<MQ2DanNet::Observe>(local_peer, Index);
                    }
                    return true;
                } else
                    return false;
            case Q:
            case Query:
                Dest = Node::get().query(Index ? Index : "").data;
                if (Index && Index[0] != '\0' && Dest.Type == 0) {
                    strcpy_s(Buf, "NULL");
                    Dest.Ptr = Buf;
                    Dest.Type = pStringType;

                    Node::get().whisper<MQ2DanNet::Query>(local_peer, Index);
                }
                return true;
            }
        }

        // default case, don't have a definition for member
        strcpy_s(Buf, "NULL");
        Dest.Ptr = Buf;
        Dest.Type = pStringType;
        return false;
    }

    void SetPeer(const std::string& peer) {
        if (Node::get().debugging())
            WriteChatf("MQ2DanNetType::SetPeer setting peer from %s to %s", Peer.c_str(), peer.c_str());
        Peer = peer;
    }

    bool ToString(MQ2VARPTR VarPtr, char* Destination) {
        strcpy_s(Destination, MAX_STRING, Peer.empty() ? "NULL" : Peer.c_str());
        Peer.clear();
        return true;
    }

    bool FromData(MQ2VARPTR &VarPtr, MQ2TYPEVAR &Source) { return false; }
    bool FromString(MQ2VARPTR &VarPtr, char* Source) { return false; }
};

BOOL dataDanNet(PCHAR Index, MQ2TYPEVAR &Dest) {
    Dest.DWord = 1;
    Dest.Type = pDanNetType;

    if (Node::get().debugging())
        WriteChatf("MQ2DanNetType::dataDanNet Index %s", Index);
    if (!Index || Index[0] == '\0' || !Node::get().has_peer(Index))
        pDanNetType->SetPeer("");
    else
        pDanNetType->SetPeer(Node::get().get_full_name(Index));

    return true;
}

PLUGIN_API VOID DInfoCommand(PSPAWNINFO pSpawn, PCHAR szLine) {
    CHAR szParam[MAX_STRING] = { 0 };
    GetArg(szParam, szLine, 1);

    if (szParam && !strcmp(szParam, "interface")) {
        GetArg(szParam, szLine, 2);
        if (szParam && strlen(szParam) > 0) {
            WritePrivateProfileString("MQ2DanNet", "Interface", szParam, INIFileName);
            WriteChatf("MQ2DanNet: Set interface to %s", szParam);
        } else {
            WriteChatf("MQ2DanNet: Interfaces --\r\n%s", Node::get().get_interfaces());
        }
    } else if (szParam && !strcmp(szParam, "debug")) {
        GetArg(szParam, szLine, 2);
        if (szParam && !strcmp(szParam, "on")) {
            Node::get().debugging(true);
            WritePrivateProfileString("MQ2DanNet", "Debugging", "1", INIFileName);
        } else if (szParam && !strcmp(szParam, "off")) {
            Node::get().debugging(false);
            WritePrivateProfileString("MQ2DanNet", "Debugging", "0", INIFileName);
        } else {
            Node::get().debugging(!Node::get().debugging());
            WritePrivateProfileString("MQ2DanNet", "Debugging", Node::get().debugging() ? "1" : "0", INIFileName);
        }
    } else {
        WriteChatf("MQ2DanNet: %s", Node::get().get_info().c_str());
    }
}

PLUGIN_API VOID DJoinCommand(PSPAWNINFO pSpawn, PCHAR szLine) {
    CHAR szGroup[MAX_STRING] = { 0 };
    GetArg(szGroup, szLine, 1);

    std::string group = Node::init_string(szGroup);

    if (group.empty())
        WriteChatColor("Syntax: /djoin <group> -- join named group on peer network", USERCOLOR_DEFAULT);
    else
        Node::get().join(group);
}

PLUGIN_API VOID DLeaveCommand(PSPAWNINFO pSpawn, PCHAR szLine) {
    CHAR szGroup[MAX_STRING] = { 0 };
    GetArg(szGroup, szLine, 1);

    std::string group = Node::init_string(szGroup);

    if (group.empty())
        WriteChatColor("Syntax: /dleave <group> -- leave named group on peer network", USERCOLOR_DEFAULT);
    else
        Node::get().leave(group);
}

PLUGIN_API VOID DTellCommand(PSPAWNINFO pSpawn, PCHAR szLine) {
    CHAR szName[MAX_STRING] = { 0 };
    GetArg(szName, szLine, 1);
    auto name = Node::init_string(szName);
    std::string message(szLine);
    std::string::size_type n = message.find_first_not_of(" \t", 0);
    n = message.find_first_of(" \t", n);
    message.erase(0, message.find_first_not_of(" \t", n));

    if (name.empty() || message.empty())
        WriteChatColor("Syntax: /dtell <name> <message> -- send message to name", USERCOLOR_DEFAULT);
    else {
        name = Node::get().get_full_name(name);

        WriteChatf("\ax\a-t[ \ax\at-->\ax\a-t(%s) ]\ax \aw%s\ax", name.c_str(), message.c_str());
        Node::get().whisper<MQ2DanNet::Echo>(name, message);
    }
}

PLUGIN_API VOID DGtellCommand(PSPAWNINFO pSpawn, PCHAR szLine) {
    CHAR szGroup[MAX_STRING] = { 0 };
    GetArg(szGroup, szLine, 1);
    auto group = Node::init_string(szGroup);
    std::string message(szLine);
    std::string::size_type n = message.find_first_not_of(" \t", 0);
    n = message.find_first_of(" \t", n);
    message.erase(0, message.find_first_not_of(" \t", n));

    if (group.empty() || message.empty())
        WriteChatColor("Syntax: /dgtell <group> <message> -- broadcast message to group", USERCOLOR_DEFAULT);
    else {
        WriteChatf("\ax\a-t[\ax\at -->\ax\a-t(%s) ]\ax \aw%s\ax", group.c_str(), message.c_str());
        Node::get().shout<MQ2DanNet::Echo>(group, message);
    }
}

PLUGIN_API VOID DExecuteCommand(PSPAWNINFO pSpawn, PCHAR szLine) {
    CHAR szName[MAX_STRING] = { 0 };
    GetArg(szName, szLine, 1);
    auto name = Node::init_string(szName);
    std::string command(szLine);
    std::string::size_type n = command.find_first_not_of(" \t", 0);
    n = command.find_first_of(" \t", n);
    command.erase(0, command.find_first_not_of(" \t", n));

    if (name.empty() || command.empty())
        WriteChatColor("Syntax: /dexecute <name> <command> -- direct name to execute command", USERCOLOR_DEFAULT);
    else {
        name = Node::get().get_full_name(name);

        WriteChatf("\ax\a-o[ \ax\ao-->\ax\a-o(%s) ]\ax \aw%s\ax", name.c_str(), command.c_str());
        Node::get().whisper<MQ2DanNet::Execute>(name, command);
    }
}

PLUGIN_API VOID DGexecuteCommand(PSPAWNINFO pSpawn, PCHAR szLine) {
    CHAR szGroup[MAX_STRING] = { 0 };
    GetArg(szGroup, szLine, 1);
    auto group = Node::init_string(szGroup);
    std::string command(szLine);
    std::string::size_type n = command.find_first_not_of(" \t", 0);
    n = command.find_first_of(" \t", n);
    command.erase(0, command.find_first_not_of(" \t", n));

    if (group.empty() || command.empty())
        WriteChatColor("Syntax: /dgexecute <group> <command> -- direct group to execute command", USERCOLOR_DEFAULT);
    else {
        WriteChatf("\ax\a-o[\ax\ao -->\ax\a-o(%s) ]\ax \aw%s\ax", group.c_str(), command.c_str());
        Node::get().shout<MQ2DanNet::Execute>(group, command);
    }
}

PLUGIN_API VOID DGAexecuteCommand(PSPAWNINFO pSpawn, PCHAR szLine) {
    CHAR szGroup[MAX_STRING] = { 0 };
    GetArg(szGroup, szLine, 1);
    auto group = Node::init_string(szGroup);
    std::string command(szLine);
    std::string::size_type n = command.find_first_not_of(" \t", 0);
    n = command.find_first_of(" \t", n);
    command.erase(0, command.find_first_not_of(" \t", n));

    if (group.empty() || command.empty())
        WriteChatColor("Syntax: /dgaexecute <group> <command> -- direct group to execute command", USERCOLOR_DEFAULT);
    else {
        WriteChatf("\ax\a-o[\ax\ao -->\ax\a-o(%s) ]\ax \aw%s\ax", group.c_str(), command.c_str());
        Node::get().shout<MQ2DanNet::Execute>(group, command);

        std::string final_command = std::regex_replace(command, std::regex("\\$\\\\\\{"), "${");

        CHAR szCommand[MAX_STRING] = { 0 };
        strcpy_s(szCommand, final_command.c_str());
        EzCommand(szCommand);
    }
}

PLUGIN_API VOID DObserveCommand(PSPAWNINFO pSpawn, PCHAR szLine) {
    CHAR szName[MAX_STRING] = { 0 };
    GetArg(szName, szLine, 1);
    auto name = Node::init_string(szName);
    if (std::string::npos == name.find_last_of("_"))
        name = Node::get().get_full_name(name);

    CHAR szQuery[MAX_STRING] = { 0 };
    GetArg(szQuery, szLine, 2);
    std::string query(szQuery ? szQuery : "");

    if (name.empty() || query.empty()) {
        WriteChatColor("Syntax: /dobserve <name> <query> -- start observe query on name", USERCOLOR_DEFAULT);
        WriteChatColor("        /dobserve <name> <query> [drop] -- drop observe query on name", USERCOLOR_DEFAULT);
    } else {
        CHAR szParam[MAX_STRING] = { 0 };
        GetArg(szParam, szLine, 3);

        if (szParam && Node::init_string(szParam) == "drop") {
            Node::get().forget(name, query);
        } else {
            Node::get().whisper<Observe>(name, query);
        }
    }
}

// Called once, when the plugin is to initialize
PLUGIN_API VOID InitializePlugin(VOID) {
	DebugSpewAlways("Initializing MQ2DanNet");

    Node::get().register_command<MQ2DanNet::Echo>();
    Node::get().register_command<MQ2DanNet::Execute>();
    Node::get().register_command<MQ2DanNet::Query>();
    Node::get().register_command<MQ2DanNet::Observe>();
    Node::get().register_command<MQ2DanNet::Update>();

    Node::get().debugging(GetPrivateProfileInt("MQ2DanNet", "Debugging", 0, INIFileName) != 0);

    AddCommand("/dinfo", DInfoCommand);
    AddCommand("/djoin", DJoinCommand);
    AddCommand("/dleave", DLeaveCommand);
    AddCommand("/dtell", DTellCommand);
    AddCommand("/dgtell", DGtellCommand);
    AddCommand("/dexecute", DExecuteCommand);
    AddCommand("/dgexecute", DGexecuteCommand);
    AddCommand("/dgaexecute", DGAexecuteCommand);
    AddCommand("/dobserve", DObserveCommand);

    pDanNetType = new MQ2DanNetType;
    AddMQ2Data("DanNet", dataDanNet);
}

// Called once, when the plugin is to shutdown
PLUGIN_API VOID ShutdownPlugin(VOID) {
	DebugSpewAlways("Shutting down MQ2DanNet");
    Node::get().exit();

    // this is Windows-specific and needs to be done to free some dangling select() threads
    Node::get().shutdown();

    Node::get().unregister_command<MQ2DanNet::Echo>();
    Node::get().unregister_command<MQ2DanNet::Execute>();
    Node::get().unregister_command<MQ2DanNet::Query>();
    Node::get().unregister_command<MQ2DanNet::Observe>();
    Node::get().unregister_command<MQ2DanNet::Update>();

    RemoveCommand("/dinfo");
    RemoveCommand("/djoin");
    RemoveCommand("/dleave");
    RemoveCommand("/dtell");
    RemoveCommand("/dgtell");
    RemoveCommand("/dexecute");
    RemoveCommand("/dgexecute");
    RemoveCommand("/dgaexecute");
    RemoveCommand("/dobserve");

    RemoveMQ2Data("DanNet");
    delete pDanNetType;
}

// Called once directly after initialization, and then every time the gamestate changes
PLUGIN_API VOID SetGameState(DWORD GameState) {
    // TODO: Figure out why we can't re-use the instance through zoning 
    // (it should be maintainable through the GAMESTATE_LOGGINGIN -> GAMESTATE_INGAME cycle, but causes my node instance to get memset to null)
    Node::get().exit();

    // TODO: What about other gamestates? There is potential for messaging there, but the naming would be off without a character
    if (GameState == GAMESTATE_INGAME)
        Node::get().enter();
}

// This is called every time MQ pulses
PLUGIN_API VOID OnPulse(VOID) {
    Node::get().do_next();
    Node::get().publish<Update>();
}

#pragma endregion
